fegen example2;

typeDef struct{
    parameters [list<anytype>]
    assemblyFormat['`<`custom<ElementTypes>($elemTypes)>`']
}

module
    : structDefine* funDefine+
    ;

expression
    : Number
    {   inputs [const float numberAttr]
        returns [tensor ret]
        actions {
            'double' number = function<'std::stod'>($Number().text);
            numberAttr = double<number>;
        }
        // ret = operation<toy.constant>(numberAttr);
        // 声明或使用一个operation
        ir [constant]
    }
    | tensorLiteral
    {
        inputs [float in]
        returns [tensor]
        actions {
            in = function<'getTensor'>($tensorLiteral());
        }
        ir [constant]
    }
    | identifierExpr
    {
        inputs [tensor in]
        returns [tensor ret]
        actions {ret = in;}
    }
    | expression Mul expression
    {
        inputs [tensor, tensor]
        returns [tensor]
        ir [mul]
    }
    | expression Add expression
    {
        inputs [tensor, tensor]
        returns [tensor]
        ir [add]
    }
    | expression Dot expression
    {
        inputs [struct input, const int index]
        returns [tensor output] 
        actions {
            index = function<'getMemberIndex'>($expression(1).text);
        }
        ir [StructAccessOp]
    }
    | structLiteral
    {
        inputs [cosnt array in]
        returns [struct ret]
        actions {
            // 使用时，需要把类型实例化出来 
            l = function<'getElementTypes'>($structLiteral)
            ret.type = struct<l>
        }
        ir [StructConstantOp]
    }
    ;

identifierExpr
    : Identifier
    {
        // TODO:: 组合类型的处理
        // 对组合类型进行特殊处理，比如参考toy例程里的部分
        // def Toy_Type : AnyTypeOf<[F64Tensor, Toy_StructType]>;
        returns [<tensor, struct> ret]
        actions {
            // 应该出现在td文件中
            ret.type = ret_type AnyTypeOf <tensor, struct>;
            ret = function<'findSymbol'>($Identifier().text);
        }
    }
    | Identifier ParentheseOpen (expression(Comma expression)*)? ParentheseClose 
    {
        // TODO:: callee怎么表示
        inputs [const attr callee, list<'type'> ins]
        returns [type ret]
        actions {
            // TODO: table
            callee = function<'findSymbol'>($Identifier().text);
            // TODO: how to get a list
            ins = getInputs($expression());
        }
        ir [GenericCallOp]
    }
    ; 

returnExpr
    : Return
    {
        inputs [list<'Type'> in]
        ir [ReturnOp]
    } 
    | Return expression 
    {
        inputs [list<'Type'> in]
        ir [ReturnOp]
    }
    ;

tensorLiteral
    : SbracketOpen (tensorLiteral (Comma tensorLiteral)*)? SbracketClose 
    | Number 
    ;

type
    : AngleBracketsOpen Number (Comma Number)* AngleBracketsClose
    ;

funDefine
    : prototype block
    {
        inputs [const attr symbolname, const attr functype]
        ir [func]
    }
    ;

prototype
    : Def funcName funcParams
    {
        inputs [const attr in1, const attr in2]
        returns[const attr ret1, const attr ret2]
    }
    ;

funcName
    : Identifier
    {
        inputs ['string' text]
        returns [const attr name]
        actions {
            text = $Identifier().text;
        }
        ir [SymbolNameAttr]
    }
    ;

funcParams
    : ParentheseOpen declList? ParentheseClose
    {
        inputs [list<'Type'>]
        returns [const attr]
        ir [functionType]
    }
    ;

declList
    : varDecl (Comma varDecl)*
    {
        returns [list<'Type'> ret]
        actions {
            // get types of vardecl
            ret = getTypes(varDecl);
        }
    }
    ;

varDecl
    : Var Identifier (type)? (Equal expression)?
    | Identifier Identifier (Equal expression)?
    | Identifier
    ;

block
    : BracketOpen (blockExpr Semicolon)* BracketClose
    ;
    
blockExpr
    : varDecl 
    | returnExpr 
    | expression
    ;

ParentheseOpen 
    : '('
    ;

ParentheseClose 
    : ')'
    ;

BracketOpen 
    : '{'
    ;

BracketClose 
    : '}'
    ;

SbracketOpen 
    : '['
    ;

SbracketClose 
    : ']'
    ;

Return
    : 'return'
    ;
    
Semicolon
    : ';'
    ;

Var 
    : 'var'
    ;

Def 
    : 'def'
    ;

Struct 
    : 'struct'
    ;

Identifier
    : ('a'..'z' | 'A'..'Z')('a'..'z' | 'A'..'Z' | '0'..'9' | '_')
    ; 

Number
    : ('0'..'9')+
    ;

Equal
    : '='
    ;

AngleBracketsOpen 
    : '<'
    ;

AngleBracketsClose
    : '>' 
    ;

Comma
    : ','
    ;

Add  
    : '+'
    ;

Mul 
    : '*'
    ;

Dot 
    : '.'
    ;

WS
    : ('\r' | '\t' | '\n') -> skip
    ;
    
Comment 
    : '#' .*? '\n' ->skip
    ;